# Матричный интерпретатор

## Задача

Требуется реализовать интерпретатор assembler-like языка,
работающий с матрицами произвольного размера, которые хранят
целочисленные элементы. Интерпретатор имеет следующие характеристики:

* последовательно выполняет команды, считанные из стандартного потока ввода;
* матрицы хранятся в *десяти* регистрах;
* нумерация регистров начинается с *нуля*;
* по умолчанию в регистре хранится матрица размера `0 x 0`.

Должны поддерживаться следующие команды (см. подробное описание ниже):

| Команда | Семантика |
|---|---|
| load *reg* *fname* | Загружает матрицу из файла *fname* в *reg*. |
| print *reg* | Печать матрицы на экран. |
| add *reg1* *reg2* | Сложение матриц. |
| mul *reg1* *reg2* | Умножение матриц. |
| elem *reg* *i* *j* | Печать элемента на экран. |
| exit | Завершение работы программы. |

## Описание команд

### Общее
* имя регистра в начинается с `$`;
* имена регистров всегда корректны (`$0`-`$9`);
* если по команда не может быть выполнена, значения регистров не изменяются.

### load *reg* *fname*

Команда загружает матрицу из файла с именем *fname* в регистр *reg*.
Формат хранения матрицы:
```
<#rows, положительное целое> <#cols, положительное целое>
<element 0-0> ... <element 0-#cols>
...
<element #rows-0> ... <element #rows-#cols>
```
Элементы матрицы - целые числа, 4 байта.

##### Пример работы

```
> cat mtx
2 3
1 2 3
4 5 6
> ./main
load $0 mtx
print $0
1 2 3
4 5 6
exit
>
```

##### Допущения
* загружаемый файл с матрицей всегда существует, его формат корректен.

### print *reg*
Команда построчно печатает элементы матрицы, хранящейся в *reg*.

##### Пример работы

```
> cat mtx
2 1
1
-1
> ./main
load $1 mtx
print $1
1
-1
exit
>
```

### add *reg1* *rеg2*

Команда поэлементно суммирует матрицу из *reg1* и матрицу из *reg2*.
Результат записывается в *reg1*. Если размеры матриц не совпадают,
на экран выводится сообщение `ADD: dimensions do not match.`.

##### Пример работы

```
> cat mtx1
2 2
1 2
3 4
> cat mtx2
2 2
-1 2
3 -4
> ./main
load $1 mtx1
load $2 mtx2
add $2 $1
print $2
0 4
6 0
print $1
1 2
3 4
add $1 $0
ADD: dimensions do not match.
exit
>
```

### mul *reg1* *reg2*

Команда умножает матрицу из *reg1* и матрицу из *reg2*.
Результат записывается в *reg1*. Если размеры матриц не позволяют выполнить
умножение, на экран выводится сообщение `MUL: #arg1.columns != #arg2.rows.`.

##### Пример работы

```
> cat mtx1
2 2
1 2
3 4
> cat mtx2
2 2
-1 2
3 -4
> ./main
load $1 mtx1
load $2 mtx2
mul $2 $1
print $2
5 6
-9 -10
print $1
1 2
3 4
mul $1 $0
MUL: #arg1.columns != #arg2.rows.
exit
>
```

### elem *reg* *i* *j*

Команда печатает на экран элемент матрицы из *reg*, находящийся в строке *i* и
столбце *j* (нумерация с нуля). Если элемента не существует,
на экран выводится сообщение `ACCESS: bad index.`.

##### Пример работы

```
> cat mtx1
2 2
1 2
3 4
> ./main
load $1 mtx1
elem $1 0 1
2
elem $1 -2 0
ACCESS: bad index.
exit
>
```

### exit
Команда завершает работу интерпретатора с кодом `0`.

##### Пример работы

```
> echo exit | ./main && echo $?
0
>
```

## Формальные требования к решению

### Реализация

* В вашем репозитории должна появиться папка с названием `lab_14` и
следующей структурой внутри:
  ```
  > pwd
  <корень-репозитория>
  > tree lab_14
  lab_14
  ├── include
  │   └── matrix.h
  ├── Makefile
  └── src
      ├── main.cpp
      └── matrix.cpp
  ```
  При этом:

  * При запуске команды make под Linux из папки `lab_14` исходный код
      должен компилироваться в файл   `main` (исходники могут иметь любые
      имена).
  * При запуске команды `make clean` из папки `lab_14` все артефакты
      сборки должны удаляться.

* Класс `Matrix` хранит элементы в произвольной структуре, его интерфейс
требуется разработать самостоятельно.
* Необходимо реализовать тип `MatrixException`,
  который хранит информацию о причине сбоя.
* Проверка команд на валидность должно происходить в методах класса `Matrix`.
  Если операция не может быть выполнена, метод бросает объект типа
  `MatrixException`.
* Валидация параметров методов `Matrix` в коде интерпретатора запрещена.

## Система оценки

Баллы распределяются так:

* От 0 до 7 баллов - корректность решения.
* От 0 до 3 баллов - стиль кода.
